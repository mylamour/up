"""Config file templates for Claude and Cursor."""

from pathlib import Path
from datetime import date


def create_config_files(target_dir: Path, ai_target: str, force: bool = False) -> None:
    """Create config files for AI assistants."""
    if ai_target in ("claude", "both"):
        _create_claude_md(target_dir, force)
    if ai_target in ("cursor", "both"):
        _create_cursor_rules_dir(target_dir, force)
        _create_cursorrules(target_dir, force)


def _write_file(path: Path, content: str, force: bool) -> None:
    if path.exists() and not force:
        return
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content)


def _create_claude_md(target_dir: Path, force: bool) -> None:
    """Create CLAUDE.md for Claude Code."""
    today = date.today().isoformat()
    project_name = target_dir.name
    
    content = f"""# {project_name}

> AI Instructions for Claude Code

**Version**: 1.0.0
**Updated**: {today}
**Min Claude Version**: 2024.01

---

## Quick Start

1. Read `docs/CONTEXT.md` for current state
2. Check `docs/handoff/LATEST.md` for recent work
3. Use `docs/INDEX.md` to find relevant docs

## Project Structure

```
{project_name}/
â”œâ”€â”€ CLAUDE.md              # This file - AI reads first
â”œâ”€â”€ docs/                  # Documentation
â”‚   â”œâ”€â”€ CONTEXT.md         # Current project state
â”‚   â”œâ”€â”€ INDEX.md           # Doc quick reference
â”‚   â””â”€â”€ handoff/           # Session continuity
â”œâ”€â”€ src/                   # Source code
â”œâ”€â”€ tests/                 # Tests
â””â”€â”€ .claude/skills/        # Claude skills
```

## AI Vibing Coding Rules

### Golden Rules

1. **Vision before code** - Understand architecture first
2. **One thing at a time** - Numbered, atomic requests
3. **Verify immediately** - Test after each change
4. **Context is king** - Use @file references
5. **Frustration = signal** - Change approach when stuck

### Request Format

```
1. [ACTION] [TARGET] [CONTEXT]
2. [ACTION] [TARGET] [CONTEXT]
```

### 2-Failure Rule

If something fails twice:
1. Provide more context
2. Reference specific files
3. Break into smaller steps
4. Consider using a skill

## Skills

| Skill | Command | When to Use |
|-------|---------|-------------|
| Docs | `/docs` | Create/manage documentation |
| Learn | `/learn` | Research and create PRD |
| Product Loop | `/product-loop` | Development with SESRC |

### Skill Usage Examples

```
# Research before implementing
/learn auto

# Start development loop
/product-loop

# Create documentation
/docs new feature
```

## Auto-Triggers

| Trigger | Action |
|---------|--------|
| New feature request | `/learn auto` |
| Start coding | `/product-loop` |
| Need documentation | `/docs new [type]` |
| Session end | Update `docs/handoff/LATEST.md` |

## Context Budget

This project tracks context window usage:
- **Budget**: 100,000 tokens
- **Warning**: At 80% usage
- **Action**: Summarize and checkpoint at 90%

See `.up/state.json` for current usage (unified state file).

## Code Style

### General

- Use descriptive names
- Keep functions small
- Document public APIs
- Write tests for new features

### Python (if applicable)

- Use type hints
- Follow PEP 8
- Use dataclasses for data structures

### TypeScript (if applicable)

- Strict mode enabled
- Prefer interfaces over types
- Use async/await

## Testing

Before committing:
1. Run tests: `pytest` or `npm test`
2. Check types: `mypy` or `tsc --noEmit`
3. Lint: `ruff` or `eslint`

## Handoff Protocol

At session end, update `docs/handoff/LATEST.md`:
1. What was accomplished
2. Current blockers
3. Suggested next steps
4. Files modified

---

*Generated by up-cli*
"""
    _write_file(target_dir / "CLAUDE.md", content, force)


def _create_cursor_rules_dir(target_dir: Path, force: bool) -> None:
    """Create .cursor/rules/ directory with rule files."""
    rules_dir = target_dir / ".cursor/rules"
    rules_dir.mkdir(parents=True, exist_ok=True)
    
    # Create main rules file
    _create_main_cursor_rule(rules_dir, force)
    
    # Create file-specific rules
    _create_python_rule(rules_dir, force)
    _create_typescript_rule(rules_dir, force)
    _create_docs_rule(rules_dir, force)
    _create_test_rule(rules_dir, force)


def _create_main_cursor_rule(rules_dir: Path, force: bool) -> None:
    """Create main Cursor rule file."""
    content = """---
description: Main project rules for AI assistance
globs: ["**/*"]
---

# Project Rules

## Skills Available

- `/docs` - Documentation management
- `/learn` - Research and PRD generation
- `/product-loop` - SESRC development workflow

## Workflow

1. **Research**: `/learn auto` - Analyze project and generate insights
2. **Build**: `/product-loop` - Development with circuit breaker
3. **Document**: `/docs new` - Create documentation

## Code Quality

- Always run tests after changes
- Use type hints (Python) or TypeScript strict mode
- Keep functions under 50 lines
- Document public APIs

## Context Management

- Read `docs/CONTEXT.md` for current state
- Update `docs/handoff/LATEST.md` at session end
- Reference specific files with @file syntax

## Error Handling

If something fails twice:
1. Add more context
2. Break into smaller steps
3. Consider a different approach
"""
    _write_file(rules_dir / "main.md", content, force)


def _create_python_rule(rules_dir: Path, force: bool) -> None:
    """Create Python-specific Cursor rule."""
    content = """---
description: Python code standards
globs: ["**/*.py"]
---

# Python Rules

## Style

- Use type hints for all function signatures
- Follow PEP 8 naming conventions
- Use dataclasses for data structures
- Prefer pathlib over os.path

## Imports

```python
# Standard library
import os
from pathlib import Path

# Third-party
import click
from rich.console import Console

# Local
from mypackage.module import function
```

## Documentation

```python
def function_name(param: str, count: int = 0) -> bool:
    \"\"\"Brief description.
    
    Args:
        param: Description of param
        count: Description with default
        
    Returns:
        Description of return value
        
    Raises:
        ValueError: When param is invalid
    \"\"\"
```

## Testing

- Use pytest
- Name test files `test_*.py`
- Use fixtures for setup
- Aim for >80% coverage

## Common Patterns

### Error Handling
```python
try:
    result = operation()
except SpecificError as e:
    logger.error(f"Operation failed: {e}")
    raise
```

### Configuration
```python
@dataclass
class Config:
    debug: bool = False
    timeout: int = 30
```
"""
    _write_file(rules_dir / "python.md", content, force)


def _create_typescript_rule(rules_dir: Path, force: bool) -> None:
    """Create TypeScript-specific Cursor rule."""
    content = """---
description: TypeScript code standards
globs: ["**/*.ts", "**/*.tsx"]
---

# TypeScript Rules

## Style

- Enable strict mode
- Use interfaces over types for objects
- Prefer async/await over promises
- Use const assertions where appropriate

## Imports

```typescript
// External packages
import React from 'react';
import { useState } from 'react';

// Internal modules
import { Component } from '@/components';
import { utils } from '@/lib';

// Types
import type { User } from '@/types';
```

## Types

```typescript
// Prefer interfaces for objects
interface User {
  id: string;
  name: string;
  email: string;
}

// Use type for unions/intersections
type Status = 'pending' | 'active' | 'completed';

// Generic constraints
function process<T extends { id: string }>(item: T): string {
  return item.id;
}
```

## React Components (if applicable)

```tsx
interface Props {
  title: string;
  onAction: () => void;
}

export function Component({ title, onAction }: Props) {
  const [state, setState] = useState(false);
  
  return (
    <div>
      <h1>{title}</h1>
      <button onClick={onAction}>Action</button>
    </div>
  );
}
```

## Testing

- Use Jest or Vitest
- Name test files `*.test.ts` or `*.spec.ts`
- Mock external dependencies
"""
    _write_file(rules_dir / "typescript.md", content, force)


def _create_docs_rule(rules_dir: Path, force: bool) -> None:
    """Create documentation-specific Cursor rule."""
    content = """---
description: Documentation standards
globs: ["docs/**/*.md", "*.md"]
---

# Documentation Rules

## Structure

All docs should have:
1. Title (H1)
2. Metadata (Updated date, Status)
3. Horizontal rule separator
4. Content sections

## Header Template

```markdown
# Document Title

**Updated**: YYYY-MM-DD
**Status**: ðŸ”„ Active | âœ… Completed | ðŸ“‹ Draft

---
```

## Status Icons

| Icon | Meaning |
|------|---------|
| ðŸ“‹ | Draft/Planned |
| ðŸ”„ | Active/In Progress |
| âœ… | Completed |
| â¸ï¸ | Paused |
| âŒ | Cancelled |

## Tables

Use tables for structured information:

```markdown
| Column 1 | Column 2 |
|----------|----------|
| Value 1 | Value 2 |
```

## Code Blocks

Always specify language:

```python
def example():
    pass
```

## Links

- Use relative paths for internal docs
- Use descriptive link text
- Example: [Architecture Overview](./architecture/README.md)

## Key Files

| File | Purpose |
|------|---------|
| docs/CONTEXT.md | AI reads first |
| docs/INDEX.md | Quick reference |
| docs/handoff/LATEST.md | Session continuity |
"""
    _write_file(rules_dir / "docs.md", content, force)


def _create_test_rule(rules_dir: Path, force: bool) -> None:
    """Create test-specific Cursor rule."""
    content = """---
description: Testing standards
globs: ["tests/**/*", "**/*.test.*", "**/*.spec.*"]
---

# Testing Rules

## Structure

```
tests/
â”œâ”€â”€ unit/           # Unit tests
â”œâ”€â”€ integration/    # Integration tests
â”œâ”€â”€ fixtures/       # Test fixtures
â””â”€â”€ conftest.py     # Shared fixtures (pytest)
```

## Naming

- Test files: `test_*.py` or `*.test.ts`
- Test functions: `test_[what]_[condition]_[expected]`
- Example: `test_login_with_invalid_password_returns_401`

## AAA Pattern

```python
def test_example():
    # Arrange
    user = create_user()
    
    # Act
    result = user.login("password")
    
    # Assert
    assert result.success is True
```

## Fixtures

```python
@pytest.fixture
def user():
    return User(name="test", email="test@example.com")

def test_with_fixture(user):
    assert user.name == "test"
```

## Mocking

```python
from unittest.mock import Mock, patch

@patch('module.external_service')
def test_with_mock(mock_service):
    mock_service.return_value = {'status': 'ok'}
    result = function_under_test()
    assert result == 'ok'
```

## Coverage

- Aim for >80% coverage
- Focus on critical paths
- Don't test trivial code
"""
    _write_file(rules_dir / "tests.md", content, force)


def _create_cursorrules(target_dir: Path, force: bool) -> None:
    """Create root .cursorrules for Cursor AI."""
    content = """# Cursor Rules

## Project Overview

This project uses the up-cli scaffolding system with three integrated skills:
- `/docs` - Documentation management
- `/learn` - Research and PRD generation  
- `/product-loop` - SESRC development workflow

## Quick Reference

| Action | Command |
|--------|---------|
| Analyze project | `/learn auto` |
| Start dev loop | `/product-loop` |
| Create docs | `/docs new [type]` |
| Check status | `/product-loop status` |

## Rules Location

See `.cursor/rules/` for detailed rules:
- `main.md` - General project rules
- `python.md` - Python standards
- `typescript.md` - TypeScript standards
- `docs.md` - Documentation standards
- `tests.md` - Testing standards

## Context Files

1. `docs/CONTEXT.md` - Current project state
2. `docs/INDEX.md` - Documentation index
3. `docs/handoff/LATEST.md` - Last session handoff

## Workflow

1. Read context files first
2. Use appropriate skill commands
3. Test changes before committing
4. Update handoff at session end
"""
    _write_file(target_dir / ".cursorrules", content, force)
